import { parse } from 'node-html-parser';
import fs from 'node:fs';
import path from 'node:path';
import pi from 'picocolors';
import { optimize } from 'svgo';

const argv = process.argv.slice(2);
const cwd = process.cwd();

console.log(pi.cyan('ICOGEN'));
console.log(pi.gray('Generate SVG sprites from svg files in bulk\n'));

const ARGS = {
  FORCE: argv.includes('-f') || argv.includes('--force'),
  NO_EMIT: argv.includes('--no-emit'),
};
const PATHS = {
  SOURCE: path.join(cwd, 'public/icons/.icons'),
  SPRITE: path.join(cwd, 'public/icons/sprite.svg'),
};

/** @type {'FORCE'|'RUN'|'EXTRACTION'} */
let MODE = ARGS.FORCE ? 'FORCE' : 'RUN';

// check if the input directory exists
if (!fs.existsSync(PATHS.SOURCE)) {
  console.log(pi.red(`× input directory not found`));
  console.log(pi.dim(`  keep all icons inside "${PATHS.SOURCE}"`));
  process.exit(1);
}

const files = fs
  .readdirSync(PATHS.SOURCE)
  .filter((file) => file.endsWith('.svg'));

if (files.length === 0) {
  console.log(pi.dim(`× no svg files found in "${PATHS.SOURCE}"`));
} else if (ARGS.NO_EMIT) {
  console.log(pi.dim('× no file is generated'));
} else {
  generateFiles();
}

/** generates both svg sprite and types */
async function generateFiles() {
  // ensure the directory for output exists
  ensureDirectory(PATHS.SPRITE, true);

  // get all icon names
  const iconNames = files.map((file) => iconName(file));

  console.log(pi.gray('  generating files...'));
  await createSpriteFile();
}

/** generate the svg sprite file */
async function createSpriteFile() {
  // create svg symbols for each files
  const inputFiles = files.map((file) => path.join(PATHS.SOURCE, file));
  const symbol = await Promise.all(
    inputFiles.map(async (file) => {
      const input = await readFile(file);
      const root = parse(input);
      const svg = root.querySelector('svg');
      const name = iconName(file);
      if (!svg) throw new Error('No SVG element found');
      // create symbol from svg
      svg.tagName = 'symbol';
      svg.setAttribute('id', name);
      const paramsOverride = { removeHiddenElems: false, cleanupIds: false };
      // prettier-ignore
      const removeAttrs = ['xmlns','stroke-width','stroke-linecap','stroke-linejoin'];
      const output = optimize(svg.toString(), {
        floatPrecision: 2,
        plugins: [
          { name: 'preset-default', params: { overrides: paramsOverride } },
          { name: 'removeAttrs', params: { attrs: removeAttrs } },
        ],
      });
      return [`<!-- ${name} -->`, output.data].join('\n');
    }),
  );

  const output = [
    `<?xml version="1.0" encoding="utf-8"?>`,
    `<!-- This file is generated by pnpm icogen -->`,
    `<svg xmlns="http://www.w3.org/2000/svg">`,
    `<defs>`,
    ...symbol,
    `</defs>`,
    `</svg>`,
    '', // trailing newline
  ].join('\n');

  const outFile = await writeFile(PATHS.SPRITE, output);
  if (outFile) {
    console.log(pi.green('✓'), pi.dim('sprite:'), outFile);
  }
}

/**
 * read files asynchronously
 * @param {string} file - filepath
 */
async function readFile(file) {
  if (!fs.existsSync(file)) return '';
  return await fs.promises.readFile(file, 'utf-8').catch(() => '');
}

/**
 * write to file only if content changed
 * @param {string} filePath - target file path
 * @param {string} content - file content
 */
async function writeFile(filePath, content) {
  const res = fs.writeFileSync(filePath, content, 'utf-8');
  return path.relative(cwd, filePath);
}

/**
 * ensure the directory exists
 * @param {string} dir - target directory
 * @param {boolean} isFilePath check if filepath
 */
async function ensureDirectory(dir, isFilePath = false) {
  dir = isFilePath ? path.dirname(dir) : dir;
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

/**
 * get the icon name from file
 * @param {string} file
 */
function iconName(file) {
  return path
    .basename(file)
    .replace(/\.svg$/, '')
    .toLowerCase();
}
